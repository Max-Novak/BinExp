/*
Target of this program is to over flow stack in such a way that return address
from foo function changed to some address in the above the stack (which store
the location of some address of nops of environment variable, which at the end
store the address of executable shellcode).

SHELLCODE : "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"

Assume ASLR is turned ON.

Compilation command:
gcc -m32 -g -fno-stack-protector exploit_me_4.c -o exploit_me_4

Arguments used:
	-m32: instrcuting the compiler to build 32 bit Binary.
	-g: This allow C code to visible in gdb.
	-fno-stack-protector: Disbale stack protection by canary.
    -zexecstack: stack is marked as executable.
*/

#include <stdio.h>
#include <string.h>

void foo(char *name){
	char buffer[100];
	strcpy(buffer, name);
	printf("Hello %s", buffer);
}

int main(int argc, char **argv)
{
	foo(argv[1]);
	return 0;
}


/*
Similar to lecture 2 get eip to point at shellcode
but with aslr enabled we dont know where we want to point
with a \x90 NOP sled + shellcode + junk + ebp + eip
Anytime we land on \x90 or shellcode start we get a shell 
because program just keeps executing NOPs until it finds the shellcode
*/

/*
Environment variables are stored at higher addresses so
fill buffer with junk but shoot the address around the area where the env vars are
they have up to thousands of open bytes so higher chance
*/
